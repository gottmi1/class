
4장

1. 고차함수
  - 함수를 호출할 때 마다 반환 함수를 생성하는 함수를 고차 함수라고 한다.
    
    형식) 
    const func = function(msg) => {
      return() => {
        console.log('머라고라고?');
      }
    }

  - 반환된 함수는 다른 변수에 저장할 수 있고 그 변수에 저장된 함수를 다시 호출할 수 있다.

    const inner = func;
    inner(); // 결과 console.log('뭐라고라고?');

  화살표 함수 문법에 이렇게 쓸 수 있다.

    const func = (msg) => (){
      console.log(msg)
    }
    이건 아래의 함수에서 화살표 함수 문법으로 좀 축약한 것
    const func = (msg) => {
      return() => {
        console.log(msg);
      }
    }
  

  2. if문 중첩 제거

    if문은 중첩되면 코드를 파악하기가 몹시 어렵다
    다음과 같은 방법으로 if문의 중복을 제거할 수 있으나, 굳이 무리해서 제거할 필요는 또 없는 것 같음.

      1)공통된 절차(결과에 상관 없이 실행되는 절차)는 각 분기점 내부에 넣는다.
      2)분기점에서 짧은 절차부터 실행하게 if문을 작성한다. (만약 결과가 false일 경우가 더 짧다면 조건을 (!true) 이렇게 놓고 false 결과를 먼저 쓴다)
      3)짧은 절차가 끝나면 retrun이나 break로 중단한다
      4)else를 제거한다 (이 떄 중첩 하나가 제거됨);


5장



6장 

1. 피셔 에이츠 셔플 알고리즘

  숫자를 무작위로 섞는 방법을 말한다.
  먼저 무작위 인덱스를 하나 뽑은 후 그에 해당하는 요소를 새로운 배열로 옮긴다.
  이를 반복하면 새 배열에 무작위로 섞인 숫자가 들어가게 됨.

  형식)
    const candidate = Array(랜덤하게 섞고싶은 숫자).fill().map((v,i) => i + 1); v는 그냥 쓴거같고 i는 처음 요소에 0이 아니라 1이 들어가게 하려고 1을 더했음

  
2. sort 

  비교함수에 적힌 애용대로 배열을 정리해준다.

  형식)
    배열.sort(비교함수)

  이 때 비교함수는 다음과 같음.

    ((a,b) => a-b)
    오름차순으로 정리
    ((a,b) => b-a)
    내림차순으로 정리

  반환 값이 0보다 크면 b->a순으로 정렬되고 0보다 크면 a->b 순으로 정렬됨. 여기서 아마 a가 앞 숫자고 b가 뒷 숫자일거임.



7장 

1. 배열.includes 

  ||를 이용한 코드는 배열의 includes메서드로 반복을 줄일 수 있다.

  diff === '바나나' || diff === '사과' || diff === '오렌지';
  ['바나나,'사과','오렌지'].includes(diff);
  같은 동작을 함


8장

1. 배열.reduce

   reduce는 배열에 있는 반복 메서드의 일종으로 배열의 요소들을 하나의 값으로 합친다.

    형식)
    배열.reduce(누적값, 현재값) => {
      return 새로운 누적 값;
    } , 초기값);

  함수에서 반환되는 값은 다음 동작 할 때의 누적값이 되고, 마지막으로 반환되는 값이 reduce 메서드의 결과값이 된다.
  초기값을 지정하지 않으면 배열의 첫 번째 요소가 초기값이 됨.



9장


1. 이벤트 버블링

  이벤트 버블링은 이베트가 발생할 때 부모 태그에도 동일한 이벤트가 발생하게 되는 현상을 말한다.
  td의 부모태그가 tr이고 tr의 부모태그는 table일 때 td 태그를 클릭하여 td태그에 click이벤트가 발생하면 td의 부모인 tr과 table까지도 이벤트가 발생하는 것.
  즉 자식의 이벤트가 부모까지 전달되는 것이다.

  이 현상이 일어날 때 이벤트 리스너의 콜백함수 event자리는 이벤트가 발생한 태그로 바뀌므로 주의해야한다.
  이벤트가 발생한 태그가 아닌 그냥 addEventListener를 추가한 태그에 접근하고 싶다면 event.currentTarget을 사용해야한다.


2. parentNode와 children

  parentNode는 해당 요소의 부모 요소에 접근하는 것이고 children은 해당 요소의 자식 요소에 접근하는 것이다.
  이벤트타겟에 쓸 일이 많을 것 같다. 자식태그는 여러개일 수 있으므로 배열의 형식을 갖는데, 진짜 배열은 아니고 배열과 유사한 객체이다.


3. Arrat.from

 위에서 언급한 배열과 유사한 객체에는 배열의 메서드를 사용할 수 없는데, Array.from으로 배열화 시켜주면 배열 메서드를 쓸수가 있어진다.

  형식) Array.from(body.children).indexOf(body);

문자열도 Array.from으로 배열로 바꿀 수 있다.

Array.from('뭘봐 씨발년아'); // ['뭘','봐', '', '씨','발','년','아']


4. rowIndex와 cellIndex 

 이새끼들은 그냥 열의 정보와 칸의 정보를 자동으로 받는 새끼들이다
 tr은 rowIndex로 해당 줄의 정보를 자동으로 받고 td는 cellIndex로 해당 칸의 정보(위치등)를 자동으로 받음.


5. every와 some

  얘네들은 성능좋은 반복문들인데, if나 switch, forEach문은 조건에 맞는 요소를 찾아도 일단 끝까지 반복하는데 얘네들은 조건에 해당하는 요소를 찾게되면 반복을 멈춰서 부하가 적다

    형식)
    배열.every(조건함수);
    배열.some((어쩌구) => 저쩌구)

  every는 하나라도 만족하지 않을경우 false를 뱉고,
  some은 하나라도 만족할경우 true를 뱉는다.

  const draw = rows.flat().every((cell) => cell.textContent);
  every를 사용한 형식인데, 앞에건 볼거 없고 조건함수가 ((cell) => cell.textContent); 인 것이 중요하다
  위 함수는 cell에 textContent가 전부 차면 draw를 true로 받겠다는 이야기다
  하튼 every뒤에 들어오는 조건은 true나 false를 뱉게 될 조건이라고 생각하면 좋을듯.


6. flat

  flat은 배열의 차원을 한 단계 낮춰주는 메서드다. 1차원 배열에는 안 먹는다. 두 번 내리고 싶으면 2중첩으로 쓰면된다 참 쉽다.
  1중첩은 array.flat()
  2중첩은 array.flat().flat();
  이렇게 하면 된다.

